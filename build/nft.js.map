{"version":3,"file":"nft.js","sources":["../node_modules/near-sdk-js/lib/near-bindgen.js","../node_modules/near-sdk-js/lib/api.js","../node_modules/near-sdk-js/lib/near-contract.js","../node_modules/near-sdk-js/lib/collections/lookup-map.js","../node_modules/near-sdk-js/lib/utils.js","../node_modules/near-sdk-js/lib/collections/vector.js","../node_modules/near-sdk-js/lib/collections/unordered-map.js","../node_modules/near-sdk-js/lib/collections/unordered-set.js","../src/nft-contract/metadata.ts","../src/nft-contract/internal.ts","../src/nft-contract/mint.ts","../src/nft-contract/nft_core.ts","../src/nft-contract/enumeration.ts","../src/nft-contract/approval.ts","../src/nft-contract/royalty.ts","../src/nft-contract/index.ts"],"sourcesContent":["export function call(target, key, descriptor) {\n}\nexport function view(target, key, descriptor) {\n}\nexport function NearBindgen(target) {\n    return class extends target {\n        static _init() {\n            // @ts-ignore\n            let args = target.deserializeArgs();\n            let ret = new target(args);\n            // @ts-ignore\n            ret.init();\n            // @ts-ignore\n            ret.serialize();\n            return ret;\n        }\n        static _get() {\n            let ret = Object.create(target.prototype);\n            return ret;\n        }\n    };\n}\n","const U64_MAX = 2n ** 64n - 1n;\nconst EVICTED_REGISTER = U64_MAX - 1n;\nexport function log(...params) {\n    env.log(`${params\n        .map(x => x === undefined ? 'undefined' : x) // Stringify undefined\n        .map(x => typeof (x) === 'object' ? JSON.stringify(x) : x) // Convert Objects to strings\n        .join(' ')}` // Convert to string\n    );\n}\nexport function signerAccountId() {\n    env.signer_account_id(0);\n    return env.read_register(0);\n}\nexport function signerAccountPk() {\n    env.signer_account_pk(0);\n    return env.read_register(0);\n}\nexport function predecessorAccountId() {\n    env.predecessor_account_id(0);\n    return env.read_register(0);\n}\nexport function blockIndex() {\n    return env.block_index();\n}\nexport function blockHeight() {\n    return blockIndex();\n}\nexport function blockTimestamp() {\n    return env.block_timestamp();\n}\nexport function epochHeight() {\n    return env.epoch_height();\n}\nexport function attachedDeposit() {\n    return env.attached_deposit();\n}\nexport function prepaidGas() {\n    return env.prepaid_gas();\n}\nexport function usedGas() {\n    return env.used_gas();\n}\nexport function randomSeed() {\n    env.random_seed(0);\n    return env.read_register(0);\n}\nexport function sha256(value) {\n    env.sha256(value, 0);\n    return env.read_register(0);\n}\nexport function keccak256(value) {\n    env.keccak256(value, 0);\n    return env.read_register(0);\n}\nexport function keccak512(value) {\n    env.keccak512(value, 0);\n    return env.read_register(0);\n}\nexport function ripemd160(value) {\n    env.ripemd160(value, 0);\n    return env.read_register(0);\n}\nexport function ecrecover(hash, sig, v, malleabilityFlag) {\n    let ret = env.ecrecover(hash, sig, v, malleabilityFlag, 0);\n    if (ret === 0n) {\n        return null;\n    }\n    return env.read_register(0);\n}\nexport function panic(msg) {\n    if (msg !== undefined) {\n        env.panic(msg);\n    }\n    else {\n        env.panic();\n    }\n}\nexport function panicUtf8(msg) {\n    env.panic_utf8(msg);\n}\nexport function logUtf8(msg) {\n    env.log_utf8(msg);\n}\nexport function logUtf16(msg) {\n    env.log_utf16(msg);\n}\nexport function storageRead(key) {\n    let ret = env.storage_read(key, 0);\n    if (ret === 1n) {\n        return env.read_register(0);\n    }\n    else {\n        return null;\n    }\n}\nexport function storageHasKey(key) {\n    let ret = env.storage_has_key(key);\n    if (ret === 1n) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nexport function validatorStake(accountId) {\n    return env.validator_stake(accountId);\n}\nexport function validatorTotalStake() {\n    return env.validator_total_stake();\n}\nexport function altBn128G1Multiexp(value) {\n    env.alt_bn128_g1_multiexp(value, 0);\n    return env.read_register(0);\n}\nexport function altBn128G1Sum(value) {\n    env.alt_bn128_g1_sum(value, 0);\n    return env.read_register(0);\n}\nexport function altBn128PairingCheck(value) {\n    let ret = env.alt_bn128_pairing_check(value);\n    if (ret === 1n) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nexport function jsvmAccountId() {\n    env.jsvm_account_id(0);\n    return env.read_register(0);\n}\nexport function jsvmJsContractName() {\n    env.jsvm_js_contract_name(0);\n    return env.read_register(0);\n}\nexport function jsvmMethodName() {\n    env.jsvm_method_name(0);\n    return env.read_register(0);\n}\nexport function jsvmArgs() {\n    env.jsvm_args(0);\n    return env.read_register(0);\n}\nexport function jsvmStorageWrite(key, value) {\n    let exist = env.jsvm_storage_write(key, value, EVICTED_REGISTER);\n    if (exist === 1n) {\n        return true;\n    }\n    return false;\n}\nexport function jsvmStorageRead(key) {\n    let exist = env.jsvm_storage_read(key, 0);\n    if (exist === 1n) {\n        return env.read_register(0);\n    }\n    return null;\n}\nexport function jsvmStorageRemove(key) {\n    let exist = env.jsvm_storage_remove(key, EVICTED_REGISTER);\n    if (exist === 1n) {\n        return true;\n    }\n    return false;\n}\nexport function jsvmStorageHasKey(key) {\n    let exist = env.jsvm_storage_has_key(key);\n    if (exist === 1n) {\n        return true;\n    }\n    return false;\n}\nexport function jsvmCallRaw(contractName, method, args) {\n    env.jsvm_call(contractName, method, JSON.stringify(args), 0);\n    return env.read_register(0);\n}\nexport function jsvmCall(contractName, method, args) {\n    let ret = jsvmCallRaw(contractName, method, args);\n    if (ret === null) {\n        return ret;\n    }\n    return JSON.parse(ret);\n}\nexport function storageGetEvicted() {\n    return env.read_register(EVICTED_REGISTER);\n}\nexport function jsvmValueReturn(value) {\n    env.jsvm_value_return(value);\n}\n// Standalone only APIs\nexport function currentAccountId() {\n    env.current_account_id(0);\n    return env.read_register(0);\n}\nexport function input() {\n    env.input(0);\n    return env.read_register(0);\n}\nexport function storageUsage() {\n    return env.storage_usage();\n}\nexport function accountBalance() {\n    return env.account_balance();\n}\nexport function accountLockedBalance() {\n    return env.account_locked_balance();\n}\nexport function valueReturn(value) {\n    env.value_return(value);\n}\nexport function promiseCreate(accountId, methodName, args, amount, gas) {\n    return env.promise_create(accountId, methodName, args, amount, gas);\n}\nexport function promiseThen(promiseIndex, accountId, methodName, args, amount, gas) {\n    return env.promise_then(promiseIndex, accountId, methodName, args, amount, gas);\n}\nexport function promiseAnd(...promiseIndex) {\n    return env.promise_and(...promiseIndex);\n}\nexport function promiseBatchCreate(accountId) {\n    return env.promise_batch_create(accountId);\n}\nexport function promiseBatchThen(promiseIndex, accountId) {\n    return env.promise_batch_then(promiseIndex, accountId);\n}\nexport function promiseBatchActionCreateAccount(promiseIndex) {\n    env.promise_batch_action_create_account(promiseIndex);\n}\nexport function promiseBatchActionDeployContract(promiseIndex, code) {\n    env.promise_batch_action_deploy_contract(promiseIndex, code);\n}\nexport function promiseBatchActionFunctionCall(promiseIndex, methodName, args, amount, gas) {\n    env.promise_batch_action_function_call(promiseIndex, methodName, args, amount, gas);\n}\nexport function promiseBatchActionTransfer(promiseIndex, amount) {\n    env.promise_batch_action_transfer(promiseIndex, amount);\n}\nexport function promiseBatchActionStake(promiseIndex, amount, publicKey) {\n    env.promise_batch_action_stake(promiseIndex, amount, publicKey);\n}\nexport function promiseBatchActionAddKeyWithFullAccess(promiseIndex, publicKey, nonce) {\n    env.promise_batch_action_add_key_with_full_access(promiseIndex, publicKey, nonce);\n}\nexport function promiseBatchActionAddKeyWithFunctionCall(promiseIndex, publicKey, nonce, allowance, receiverId, methodNames) {\n    env.promise_batch_action_add_key_with_function_call(promiseIndex, publicKey, nonce, allowance, receiverId, methodNames);\n}\nexport function promiseBatchActionDeleteKey(promiseIndex, publicKey) {\n    env.promise_batch_action_delete_key(promiseIndex, publicKey);\n}\nexport function promiseBatchActionDeleteAccount(promiseIndex, beneficiaryId) {\n    env.promise_batch_action_delete_account(promiseIndex, beneficiaryId);\n}\nexport function promiseResultsCount() {\n    return env.promise_results_count();\n}\nexport var PromiseResult;\n(function (PromiseResult) {\n    PromiseResult[PromiseResult[\"NotReady\"] = 0] = \"NotReady\";\n    PromiseResult[PromiseResult[\"Successful\"] = 1] = \"Successful\";\n    PromiseResult[PromiseResult[\"Failed\"] = 2] = \"Failed\";\n})(PromiseResult || (PromiseResult = {}));\nexport function promiseResult(resultIdx) {\n    let status = env.promise_result(resultIdx, 0);\n    if (status == PromiseResult.Successful) {\n        return env.read_register(0);\n    }\n    else if (status == PromiseResult.Failed ||\n        status == PromiseResult.NotReady) {\n        return status;\n    }\n    else {\n        panic(`Unexpected return code: ${status}`);\n    }\n}\nexport function promiseReturn(promiseIdx) {\n    env.promise_return(promiseIdx);\n}\nexport function storageWrite(key, value) {\n    let exist = env.storage_write(key, value, EVICTED_REGISTER);\n    if (exist === 1n) {\n        return true;\n    }\n    return false;\n}\nexport function storageRemove(key) {\n    let exist = env.storage_remove(key, EVICTED_REGISTER);\n    if (exist === 1n) {\n        return true;\n    }\n    return false;\n}\nexport function storageByteCost() {\n    return 10000000000000000000n;\n}\n","import * as near from \"./api\";\nexport class NearContract {\n    deserialize() {\n        const rawState = near.storageRead(\"STATE\");\n        if (rawState) {\n            const state = JSON.parse(rawState);\n            // reconstruction of the contract class object from plain object\n            let c = this.default();\n            Object.assign(this, state);\n            for (const item in c) {\n                if (c[item].constructor?.deserialize !== undefined) {\n                    this[item] = c[item].constructor.deserialize(this[item]);\n                }\n            }\n        }\n        else {\n            throw new Error(\"Contract state is empty\");\n        }\n    }\n    serialize() {\n        near.storageWrite(\"STATE\", JSON.stringify(this));\n    }\n    static deserializeArgs() {\n        let args = near.input();\n        return JSON.parse(args || \"{}\");\n    }\n    static serializeReturn(ret) {\n        return JSON.stringify(ret);\n    }\n    init() { }\n}\n","import * as near from '../api';\nexport class LookupMap {\n    constructor(keyPrefix) {\n        this.keyPrefix = keyPrefix;\n    }\n    containsKey(key) {\n        let storageKey = this.keyPrefix + JSON.stringify(key);\n        return near.storageHasKey(storageKey);\n    }\n    get(key) {\n        let storageKey = this.keyPrefix + JSON.stringify(key);\n        let raw = near.storageRead(storageKey);\n        if (raw !== null) {\n            return JSON.parse(raw);\n        }\n        return null;\n    }\n    remove(key) {\n        let storageKey = this.keyPrefix + JSON.stringify(key);\n        if (near.storageRemove(storageKey)) {\n            return JSON.parse(near.storageGetEvicted());\n        }\n        return null;\n    }\n    set(key, value) {\n        let storageKey = this.keyPrefix + JSON.stringify(key);\n        let storageValue = JSON.stringify(value);\n        if (near.storageWrite(storageKey, storageValue)) {\n            return JSON.parse(near.storageGetEvicted());\n        }\n        return null;\n    }\n    extend(objects) {\n        for (let kv of objects) {\n            this.set(kv[0], kv[1]);\n        }\n    }\n    serialize() {\n        return JSON.stringify(this);\n    }\n    // converting plain object to class object\n    static deserialize(data) {\n        return new LookupMap(data.keyPrefix);\n    }\n}\n","export function u8ArrayToBytes(array) {\n    let ret = \"\";\n    for (let e of array) {\n        ret += String.fromCharCode(e);\n    }\n    return ret;\n}\n// TODO this function is a bit broken and the type can't be string\n// TODO for more info: https://github.com/near/near-sdk-js/issues/78\nexport function bytesToU8Array(bytes) {\n    let ret = new Uint8Array(bytes.length);\n    for (let i = 0; i < bytes.length; i++) {\n        ret[i] = bytes.charCodeAt(i);\n    }\n    return ret;\n}\nexport function bytes(strOrU8Array) {\n    if (typeof strOrU8Array == \"string\") {\n        return checkStringIsBytes(strOrU8Array);\n    }\n    else if (strOrU8Array instanceof Uint8Array) {\n        return u8ArrayToBytes(strOrU8Array);\n    }\n    throw new Error(\"bytes: expected string or Uint8Array\");\n}\nfunction checkStringIsBytes(str) {\n    for (let i = 0; i < str.length; i++) {\n        if (str.charCodeAt(i) > 255) {\n            throw new Error(`string ${str} at index ${i}: ${str[i]} is not a valid byte`);\n        }\n    }\n    return str;\n}\nexport function assert(b, str) {\n    if (b) {\n        return;\n    }\n    else {\n        throw Error(\"assertion failed: \" + str);\n    }\n}\n","import * as near from \"../api\";\nimport { u8ArrayToBytes } from \"../utils\";\nconst ERR_INDEX_OUT_OF_BOUNDS = \"Index out of bounds\";\nconst ERR_INCONSISTENT_STATE = \"The collection is an inconsistent state. Did previous smart contract execution terminate unexpectedly?\";\nfunction indexToKey(prefix, index) {\n    let data = new Uint32Array([index]);\n    let array = new Uint8Array(data.buffer);\n    let key = u8ArrayToBytes(array);\n    return prefix + key;\n}\n/// An iterable implementation of vector that stores its content on the trie.\n/// Uses the following map: index -> element\nexport class Vector {\n    constructor(prefix) {\n        this.length = 0;\n        this.prefix = prefix;\n    }\n    len() {\n        return this.length;\n    }\n    isEmpty() {\n        return this.length == 0;\n    }\n    get(index) {\n        if (index >= this.length) {\n            return null;\n        }\n        let storageKey = indexToKey(this.prefix, index);\n        return JSON.parse(near.storageRead(storageKey));\n    }\n    /// Removes an element from the vector and returns it in serialized form.\n    /// The removed element is replaced by the last element of the vector.\n    /// Does not preserve ordering, but is `O(1)`.\n    swapRemove(index) {\n        if (index >= this.length) {\n            throw new Error(ERR_INDEX_OUT_OF_BOUNDS);\n        }\n        else if (index + 1 == this.length) {\n            return this.pop();\n        }\n        else {\n            let key = indexToKey(this.prefix, index);\n            let last = this.pop();\n            if (near.storageWrite(key, JSON.stringify(last))) {\n                return JSON.parse(near.storageGetEvicted());\n            }\n            else {\n                throw new Error(ERR_INCONSISTENT_STATE);\n            }\n        }\n    }\n    push(element) {\n        let key = indexToKey(this.prefix, this.length);\n        this.length += 1;\n        near.storageWrite(key, JSON.stringify(element));\n    }\n    pop() {\n        if (this.isEmpty()) {\n            return null;\n        }\n        else {\n            let lastIndex = this.length - 1;\n            let lastKey = indexToKey(this.prefix, lastIndex);\n            this.length -= 1;\n            if (near.storageRemove(lastKey)) {\n                return JSON.parse(near.storageGetEvicted());\n            }\n            else {\n                throw new Error(ERR_INCONSISTENT_STATE);\n            }\n        }\n    }\n    replace(index, element) {\n        if (index >= this.length) {\n            throw new Error(ERR_INDEX_OUT_OF_BOUNDS);\n        }\n        else {\n            let key = indexToKey(this.prefix, index);\n            if (near.storageWrite(key, JSON.stringify(element))) {\n                return JSON.parse(near.storageGetEvicted());\n            }\n            else {\n                throw new Error(ERR_INCONSISTENT_STATE);\n            }\n        }\n    }\n    extend(elements) {\n        for (let element of elements) {\n            this.push(element);\n        }\n    }\n    [Symbol.iterator]() {\n        return new VectorIterator(this);\n    }\n    clear() {\n        for (let i = 0; i < this.length; i++) {\n            let key = indexToKey(this.prefix, i);\n            near.storageRemove(key);\n        }\n        this.length = 0;\n    }\n    toArray() {\n        let ret = [];\n        for (let v of this) {\n            ret.push(v);\n        }\n        return ret;\n    }\n    serialize() {\n        return JSON.stringify(this);\n    }\n    // converting plain object to class object\n    static deserialize(data) {\n        let vector = new Vector(data.prefix);\n        vector.length = data.length;\n        return vector;\n    }\n}\nexport class VectorIterator {\n    constructor(vector) {\n        this.current = 0;\n        this.vector = vector;\n    }\n    next() {\n        if (this.current < this.vector.len()) {\n            let value = this.vector.get(this.current);\n            this.current += 1;\n            return { value, done: false };\n        }\n        return { value: null, done: true };\n    }\n}\n","import * as near from \"../api\";\nimport { u8ArrayToBytes, bytesToU8Array } from \"../utils\";\nimport { Vector, VectorIterator } from \"./vector\";\nconst ERR_INCONSISTENT_STATE = \"The collection is an inconsistent state. Did previous smart contract execution terminate unexpectedly?\";\nexport class UnorderedMap {\n    constructor(prefix) {\n        this.length = 0;\n        this.prefix = prefix;\n        this.keyIndexPrefix = prefix + \"i\";\n        let indexKey = prefix + \"k\";\n        let indexValue = prefix + \"v\";\n        this.keys = new Vector(indexKey);\n        this.values = new Vector(indexValue);\n    }\n    len() {\n        let keysLen = this.keys.len();\n        let valuesLen = this.values.len();\n        if (keysLen != valuesLen) {\n            throw new Error(ERR_INCONSISTENT_STATE);\n        }\n        return keysLen;\n    }\n    isEmpty() {\n        let keysIsEmpty = this.keys.isEmpty();\n        let valuesIsEmpty = this.values.isEmpty();\n        if (keysIsEmpty != valuesIsEmpty) {\n            throw new Error(ERR_INCONSISTENT_STATE);\n        }\n        return keysIsEmpty;\n    }\n    serializeIndex(index) {\n        let data = new Uint32Array([index]);\n        let array = new Uint8Array(data.buffer);\n        return u8ArrayToBytes(array);\n    }\n    deserializeIndex(rawIndex) {\n        let array = bytesToU8Array(rawIndex);\n        let data = new Uint32Array(array.buffer);\n        return data[0];\n    }\n    getIndexRaw(key) {\n        let indexLookup = this.keyIndexPrefix + JSON.stringify(key);\n        let indexRaw = near.storageRead(indexLookup);\n        return indexRaw;\n    }\n    get(key) {\n        let indexRaw = this.getIndexRaw(key);\n        if (indexRaw) {\n            let index = this.deserializeIndex(indexRaw);\n            let value = this.values.get(index);\n            if (value) {\n                return value;\n            }\n            else {\n                throw new Error(ERR_INCONSISTENT_STATE);\n            }\n        }\n        return null;\n    }\n    set(key, value) {\n        let indexLookup = this.keyIndexPrefix + JSON.stringify(key);\n        let indexRaw = near.storageRead(indexLookup);\n        if (indexRaw) {\n            let index = this.deserializeIndex(indexRaw);\n            return this.values.replace(index, value);\n        }\n        else {\n            let nextIndex = this.len();\n            let nextIndexRaw = this.serializeIndex(nextIndex);\n            near.storageWrite(indexLookup, nextIndexRaw);\n            this.keys.push(key);\n            this.values.push(value);\n            return null;\n        }\n    }\n    remove(key) {\n        let indexLookup = this.keyIndexPrefix + JSON.stringify(key);\n        let indexRaw = near.storageRead(indexLookup);\n        if (indexRaw) {\n            if (this.len() == 1) {\n                // If there is only one element then swap remove simply removes it without\n                // swapping with the last element.\n                near.storageRemove(indexLookup);\n            }\n            else {\n                // If there is more than one element then swap remove swaps it with the last\n                // element.\n                let lastKey = this.keys.get(this.len() - 1);\n                if (!lastKey) {\n                    throw new Error(ERR_INCONSISTENT_STATE);\n                }\n                near.storageRemove(indexLookup);\n                // If the removed element was the last element from keys, then we don't need to\n                // reinsert the lookup back.\n                if (lastKey != key) {\n                    let lastLookupKey = this.keyIndexPrefix + JSON.stringify(lastKey);\n                    near.storageWrite(lastLookupKey, indexRaw);\n                }\n            }\n            let index = this.deserializeIndex(indexRaw);\n            this.keys.swapRemove(index);\n            return this.values.swapRemove(index);\n        }\n        return null;\n    }\n    clear() {\n        for (let key of this.keys) {\n            let indexLookup = this.keyIndexPrefix + JSON.stringify(key);\n            near.storageRemove(indexLookup);\n        }\n        this.keys.clear();\n        this.values.clear();\n    }\n    toArray() {\n        let ret = [];\n        for (let v of this) {\n            ret.push(v);\n        }\n        return ret;\n    }\n    [Symbol.iterator]() {\n        return new UnorderedMapIterator(this);\n    }\n    extend(kvs) {\n        for (let [k, v] of kvs) {\n            this.set(k, v);\n        }\n    }\n    serialize() {\n        return JSON.stringify(this);\n    }\n    // converting plain object to class object\n    static deserialize(data) {\n        let map = new UnorderedMap(data.prefix);\n        // reconstruct UnorderedMap\n        map.length = data.length;\n        // reconstruct keys Vector\n        map.keys = new Vector(data.prefix + \"k\");\n        map.keys.length = data.keys.length;\n        // reconstruct values Vector\n        map.values = new Vector(data.prefix + \"v\");\n        map.values.length = data.values.length;\n        return map;\n    }\n}\nclass UnorderedMapIterator {\n    constructor(unorderedMap) {\n        this.keys = new VectorIterator(unorderedMap.keys);\n        this.values = new VectorIterator(unorderedMap.values);\n    }\n    next() {\n        let key = this.keys.next();\n        let value = this.values.next();\n        if (key.done != value.done) {\n            throw new Error(ERR_INCONSISTENT_STATE);\n        }\n        return { value: [key.value, value.value], done: key.done };\n    }\n}\n","import * as near from \"../api\";\nimport { u8ArrayToBytes, bytesToU8Array } from \"../utils\";\nimport { Vector } from \"./vector\";\nconst ERR_INCONSISTENT_STATE = \"The collection is an inconsistent state. Did previous smart contract execution terminate unexpectedly?\";\nexport class UnorderedSet {\n    constructor(prefix) {\n        this.length = 0;\n        this.prefix = prefix;\n        this.elementIndexPrefix = prefix + \"i\";\n        let elementsPrefix = prefix + \"e\";\n        this.elements = new Vector(elementsPrefix);\n    }\n    len() {\n        return this.elements.len();\n    }\n    isEmpty() {\n        return this.elements.isEmpty();\n    }\n    serializeIndex(index) {\n        let data = new Uint32Array([index]);\n        let array = new Uint8Array(data.buffer);\n        return u8ArrayToBytes(array);\n    }\n    deserializeIndex(rawIndex) {\n        let array = bytesToU8Array(rawIndex);\n        let data = new Uint32Array(array.buffer);\n        return data[0];\n    }\n    contains(element) {\n        let indexLookup = this.elementIndexPrefix + JSON.stringify(element);\n        return near.storageHasKey(indexLookup);\n    }\n    set(element) {\n        let indexLookup = this.elementIndexPrefix + JSON.stringify(element);\n        if (near.storageRead(indexLookup)) {\n            return false;\n        }\n        else {\n            let nextIndex = this.len();\n            let nextIndexRaw = this.serializeIndex(nextIndex);\n            near.storageWrite(indexLookup, nextIndexRaw);\n            this.elements.push(element);\n            return true;\n        }\n    }\n    remove(element) {\n        let indexLookup = this.elementIndexPrefix + JSON.stringify(element);\n        let indexRaw = near.storageRead(indexLookup);\n        if (indexRaw) {\n            if (this.len() == 1) {\n                // If there is only one element then swap remove simply removes it without\n                // swapping with the last element.\n                near.storageRemove(indexLookup);\n            }\n            else {\n                // If there is more than one element then swap remove swaps it with the last\n                // element.\n                let lastElement = this.elements.get(this.len() - 1);\n                if (!lastElement) {\n                    throw new Error(ERR_INCONSISTENT_STATE);\n                }\n                near.storageRemove(indexLookup);\n                // If the removed element was the last element from keys, then we don't need to\n                // reinsert the lookup back.\n                if (lastElement != element) {\n                    let lastLookupElement = this.elementIndexPrefix + JSON.stringify(lastElement);\n                    near.storageWrite(lastLookupElement, indexRaw);\n                }\n            }\n            let index = this.deserializeIndex(indexRaw);\n            this.elements.swapRemove(index);\n            return true;\n        }\n        return false;\n    }\n    clear() {\n        for (let element of this.elements) {\n            let indexLookup = this.elementIndexPrefix + JSON.stringify(element);\n            near.storageRemove(indexLookup);\n        }\n        this.elements.clear();\n    }\n    toArray() {\n        let ret = [];\n        for (let v of this) {\n            ret.push(v);\n        }\n        return ret;\n    }\n    [Symbol.iterator]() {\n        return this.elements[Symbol.iterator]();\n    }\n    extend(elements) {\n        for (let element of elements) {\n            this.set(element);\n        }\n    }\n    serialize() {\n        return JSON.stringify(this);\n    }\n    // converting plain object to class object\n    static deserialize(data) {\n        let set = new UnorderedSet(data.prefix);\n        // reconstruct UnorderedSet\n        set.length = data.length;\n        // reconstruct Vector\n        let elementsPrefix = data.prefix + \"e\";\n        set.elements = new Vector(elementsPrefix);\n        set.elements.length = data.elements.length;\n        return set;\n    }\n}\n","import { Contract } from \".\";\n\n//defines the payout type we'll be returning as a part of the royalty standards.\nexport class Payout {\n    payout: { [accountId: string]: bigint };\n    constructor({ payout }: { payout: { [accountId: string]: bigint } }) {\n        this.payout = payout;\n    }\n}\n\nexport class NFTContractMetadata {\n    spec: string;\n    name: string;\n    symbol: string;\n    icon?: string;\n    base_uri?: string;\n    reference?: string;\n    reference_hash?: string;\n    \n    constructor(\n        {\n            spec, \n            name, \n            symbol, \n            icon, \n            baseUri, \n            reference, \n            referenceHash\n        }:{ \n            spec: string, \n            name: string, \n            symbol: string, \n            icon?: string, \n            baseUri?: string, \n            reference?: string, \n            referenceHash?: string\n        }) {\n        this.spec = spec  // required, essentially a version like \"nft-1.0.0\"\n        this.name = name  // required, ex. \"Mosaics\"\n        this.symbol = symbol // required, ex. \"MOSAIC\"\n        this.icon = icon // Data URL\n        this.base_uri = baseUri // Centralized gateway known to have reliable access to decentralized storage assets referenced by `reference` or `media` URLs\n        this.reference = reference // URL to a JSON file with more info\n        this.reference_hash = referenceHash // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.\n    }\n}\n\nexport class TokenMetadata {\n    title?: string;\n    description?: string;\n    media?: string;\n    media_hash?: string;\n    copies?: number;\n    issued_at?: string;\n    expires_at?: string;\n    starts_at?: string;\n    updated_at?: string;\n    extra?: string;\n    reference?: string;\n    reference_hash?: string;\n\n    constructor(\n        {\n            title, \n            description, \n            media, \n            mediaHash, \n            copies, \n            issuedAt, \n            expiresAt, \n            startsAt, \n            updatedAt, \n            extra, \n            reference, \n            referenceHash\n        }:{\n            title?: string, \n            description?: string, \n            media?: string, \n            mediaHash?: string, \n            copies?: number, \n            issuedAt?: string, \n            expiresAt?: string, \n            startsAt?: string, \n            updatedAt?: string, \n            extra?: string, \n            reference?: string, \n            referenceHash?: string}\n        ) {\n        this.title = title // ex. \"Arch Nemesis: Mail Carrier\" or \"Parcel #5055\"\n        this.description = description // free-form description\n        this.media = media // URL to associated media, preferably to decentralized, content-addressed storage\n        this.media_hash = mediaHash // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.\n        this.copies = copies // number of copies of this set of metadata in existence when token was minted.\n        this.issued_at = issuedAt // ISO 8601 datetime when token was issued or minted\n        this.expires_at = expiresAt // ISO 8601 datetime when token expires\n        this.starts_at = startsAt // ISO 8601 datetime when token starts being valid\n        this.updated_at = updatedAt // ISO 8601 datetime when token was last updated\n        this.extra = extra // anything extra the NFT wants to store on-chain. Can be stringified JSON.\n        this.reference = reference // URL to an off-chain JSON file with more info.\n        this.reference_hash = referenceHash // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.\n    }\n}\n\nexport class Token {\n    owner_id: string;\n    approved_account_ids: { [accountId: string]: number };\n    next_approval_id: number;\n    royalty: { [accountId: string]: number };\n\n    constructor({ \n        ownerId, \n        approvedAccountIds, \n        nextApprovalId, \n        royalty \n    }:{ \n        ownerId: string, \n        approvedAccountIds: { [accountId: string]: number }, \n        nextApprovalId: number, \n        royalty: { [accountId: string]: number } \n    }) {\n        //owner of the token\n        this.owner_id = ownerId,\n        //list of approved account IDs that have access to transfer the token. This maps an account ID to an approval ID\n        this.approved_account_ids = approvedAccountIds,\n        //the next approval ID to give out. \n        this.next_approval_id = nextApprovalId,\n        //keep track of the royalty percentages for the token in a hash map\n        this.royalty = royalty\n    }\n}\n\n//The Json token is what will be returned from view calls. \nexport class JsonToken {\n    token_id: string;\n    owner_id: string;\n    metadata: TokenMetadata;\n    approved_account_ids: { [accountId: string]: number };\n    royalty: { [accountId: string]: number };\n\n    constructor({ \n        tokenId, \n        ownerId, \n        metadata, \n        approvedAccountIds, \n        royalty \n    }:{\n        tokenId: string,\n        ownerId: string,\n        metadata: TokenMetadata,\n        approvedAccountIds: { [accountId: string]: number },\n        royalty: { [accountId: string]: number }\n    }) {\n        //token ID\n        this.token_id = tokenId,\n        //owner of the token\n        this.owner_id = ownerId,\n        //token metadata\n        this.metadata = metadata,\n        //list of approved account IDs that have access to transfer the token. This maps an account ID to an approval ID\n        this.approved_account_ids = approvedAccountIds,\n        //keep track of the royalty percentages for the token in a hash map\n        this.royalty = royalty\n    }\n}\n\n//get the information for a specific token ID\nexport function internalNftMetadata({\n    contract\n}:{\n    contract: Contract\n}): NFTContractMetadata {\n    return contract.metadata;\n}","import { assert, near, UnorderedSet, Vector } from \"near-sdk-js\";\nimport { Contract, NFT_METADATA_SPEC, NFT_STANDARD_NAME } from \".\";\nimport { Token } from \"./metadata\";\n\n// Gets a collection and deserializes it into a set that can be used.\nexport function restoreOwners(collection) {\n    if (collection == null) {\n        return null;\n    }\n    return UnorderedSet.deserialize(collection as UnorderedSet);\n}\n\n//convert the royalty percentage and amount to pay into a payout (U128)\nexport function royaltyToPayout(royaltyPercentage: number, amountToPay: bigint): string {\n    return (BigInt(royaltyPercentage) * BigInt(amountToPay) / BigInt(10000)).toString();\n}\n\n//refund the storage taken up by passed in approved account IDs and send the funds to the passed in account ID. \nexport function refundApprovedAccountIdsIter(accountId: string, approvedAccountIds: string[]) {\n    //get the storage total by going through and summing all the bytes for each approved account IDs\n    let storageReleased = approvedAccountIds.map(e => bytesForApprovedAccountId(e)).reduce((partialSum, a) => partialSum + a, 0);\n    let amountToTransfer = BigInt(storageReleased) * near.storageByteCost().valueOf();\n    \n    // Send the money to the beneficiary (TODO: don't use batch actions)\n    const promise = near.promiseBatchCreate(accountId);\n    near.promiseBatchActionTransfer(promise, amountToTransfer)\n}\n\n//refund a map of approved account IDs and send the funds to the passed in account ID\nexport function refundApprovedAccountIds(accountId: string, approvedAccountIds: { [key: string]: number }) {\n    //call the refundApprovedAccountIdsIter with the approved account IDs as keys\n    refundApprovedAccountIdsIter(accountId, Object.keys(approvedAccountIds));\n}\n\n//refund the initial deposit based on the amount of storage that was used up\nexport function refundDeposit(storageUsed: bigint) {\n    //get how much it would cost to store the information\n    let requiredCost = storageUsed * near.storageByteCost().valueOf()\n    //get the attached deposit\n    let attachedDeposit = near.attachedDeposit().valueOf();\n\n    //make sure that the attached deposit is greater than or equal to the required cost\n    assert(\n        requiredCost <= attachedDeposit,\n        `Must attach ${requiredCost} yoctoNEAR to cover storage`\n    )\n\n    //get the refund amount from the attached deposit - required cost\n    let refund = attachedDeposit - requiredCost;\n    near.log(`Refunding ${refund} yoctoNEAR`);\n\n    //if the refund is greater than 1 yocto NEAR, we refund the predecessor that amount\n    if (refund > 1) {\n        // Send the money to the beneficiary (TODO: don't use batch actions)\n        const promise = near.promiseBatchCreate(near.predecessorAccountId());\n        near.promiseBatchActionTransfer(promise, refund)\n    }\n}\n\n//calculate how many bytes the account ID is taking up\nexport function bytesForApprovedAccountId(accountId: string): number {\n    // The extra 4 bytes are coming from Borsh serialization to store the length of the string.\n    return accountId.length + 4 + 8;\n}\n\n//Assert that the user has attached at least 1 yoctoNEAR (for security reasons and to pay for storage)\nexport function assertAtLeastOneYocto() {\n    assert(near.attachedDeposit().valueOf() >= BigInt(1), \"Requires attached deposit of at least 1 yoctoNEAR\");\n}\n\n//used to make sure the user attached exactly 1 yoctoNEAR\nexport function assertOneYocto() {\n    assert(near.attachedDeposit().toString() === \"1\", \"Requires attached deposit of exactly 1 yoctoNEAR\");\n}\n\n//add a token to the set of tokens an owner has\nexport function internalAddTokenToOwner(contract: Contract, accountId: string, tokenId: string) {\n    //get the set of tokens for the given account\n    let tokenSet = restoreOwners(contract.tokensPerOwner.get(accountId));\n\n    if(tokenSet == null) {\n        //if the account doesn't have any tokens, we create a new unordered set\n        tokenSet = new UnorderedSet(\"tokensPerOwner\" + accountId.toString());\n    }\n\n    //we insert the token ID into the set\n    tokenSet.set(tokenId);\n\n    //we insert that set for the given account ID. \n    contract.tokensPerOwner.set(accountId, tokenSet);\n}\n\n//remove a token from an owner (internal method and can't be called directly via CLI).\nexport function internalRemoveTokenFromOwner(contract: Contract, accountId: string, tokenId: string) {\n    //we get the set of tokens that the owner has\n    let tokenSet = restoreOwners(contract.tokensPerOwner.get(accountId));\n    //if there is no set of tokens for the owner, we panic with the following message:\n    if (tokenSet == null) {\n        near.panic(\"Token should be owned by the sender\");\n    }\n\n    //we remove the the token_id from the set of tokens\n    tokenSet.remove(tokenId)\n\n    //if the token set is now empty, we remove the owner from the tokens_per_owner collection\n    if (tokenSet.isEmpty()) {\n        contract.tokensPerOwner.remove(accountId);\n    } else { //if the token set is not empty, we simply insert it back for the account ID. \n        contract.tokensPerOwner.set(accountId, tokenSet);\n    }\n}\n\n//transfers the NFT to the receiver_id (internal method and can't be called directly via CLI).\nexport function internalTransfer(contract: Contract, senderId: string, receiverId: string, tokenId: string, approvalId: number, memo: string): Token {\n    //get the token object by passing in the token_id\n    let token = contract.tokensById.get(tokenId) as Token;\n    if (token == null) {\n        near.panic(\"no token found\");\n    }\n\n    //if the sender doesn't equal the owner, we check if the sender is in the approval list\n    if (senderId != token.owner_id) {\n        //if the token's approved account IDs doesn't contain the sender, we panic\n        if (!token.approved_account_ids.hasOwnProperty(senderId)) {\n            near.panic(\"Unauthorized\");\n        }\n\n        // If they included an approval_id, check if the sender's actual approval_id is the same as the one included\n        if (approvalId != null) {\n            //get the actual approval ID\n            let actualApprovalId = token.approved_account_ids[senderId];\n            //if the sender isn't in the map, we panic\n            if (actualApprovalId == null) {\n                near.panic(\"Sender is not approved account\");\n            }\n\n            //make sure that the actual approval ID is the same as the one provided\n            assert(actualApprovalId == approvalId, `The actual approval_id ${actualApprovalId} is different from the given approval_id ${approvalId}`);\n        }\n    }\n\n    //we make sure that the sender isn't sending the token to themselves\n    assert(token.owner_id != receiverId, \"The token owner and the receiver should be different\")\n\n    //we remove the token from it's current owner's set\n    internalRemoveTokenFromOwner(contract, token.owner_id, tokenId);\n    //we then add the token to the receiver_id's set\n    internalAddTokenToOwner(contract, receiverId, tokenId);\n\n    //we create a new token struct \n    let newToken = new Token ({\n        ownerId: receiverId,\n        //reset the approval account IDs\n        approvedAccountIds: {},\n        nextApprovalId: token.next_approval_id,\n        //we copy over the royalties from the previous token\n        royalty: token.royalty,\n    });\n\n    //insert that new token into the tokens_by_id, replacing the old entry \n    contract.tokensById.set(tokenId, newToken);\n\n    //if there was some memo attached, we log it. \n    if (memo != null) {\n        near.log(`Memo: ${memo}`);\n    }\n\n    // Default the authorized ID to be None for the logs.\n    let authorizedId;\n\n    //if the approval ID was provided, set the authorized ID equal to the sender\n    if (approvalId != null) {\n        authorizedId = senderId\n    }\n\n    // Construct the transfer log as per the events standard.\n    let nftTransferLog = {\n        // Standard name (\"nep171\").\n        standard: NFT_STANDARD_NAME,\n        // Version of the standard (\"nft-1.0.0\").\n        version: NFT_METADATA_SPEC,\n        // The data related with the event stored in a vector.\n        event: \"nft_transfer\",\n        data: [\n            {\n                // The optional authorized account ID to transfer the token on behalf of the old owner.\n                authorized_id: authorizedId,\n                // The old owner's account ID.\n                old_owner_id: token.owner_id,\n                // The account ID of the new owner of the token.\n                new_owner_id: receiverId,\n                // A vector containing the token IDs as strings.\n                token_ids: [tokenId],\n                // An optional memo to include.\n                memo,\n            }\n        ]\n    }\n\n    // Log the serialized json.\n    near.log(JSON.stringify(nftTransferLog));\n\n    //return the previous token object that was transferred.\n    return token\n}","// @ts-nocheck\nimport { assert, near } from \"near-sdk-js\";\nimport { Contract, NFT_METADATA_SPEC, NFT_STANDARD_NAME } from \".\";\nimport { internalAddTokenToOwner, refundDeposit } from \"./internal\";\nimport { Token, TokenMetadata } from \"./metadata\";\n\nexport function internalMint({\n    contract,\n    tokenId,\n    metadata,\n    receiverId,\n    perpetualRoyalties\n}:{ \n    contract: Contract, \n    tokenId: string, \n    metadata: TokenMetadata, \n    receiverId: string \n    perpetualRoyalties: {[key: string]: number}\n}): void {\n    //measure the initial storage being used on the contract TODO\n    let initialStorageUsage = near.storageUsage();\n\n    // create a royalty map to store in the token\n    let royalty: { [accountId: string]: number } = {}\n\n    // if perpetual royalties were passed into the function: TODO: add isUndefined fn\n    if (perpetualRoyalties != null) {\n        //make sure that the length of the perpetual royalties is below 7 since we won't have enough GAS to pay out that many people\n        assert(Object.keys(perpetualRoyalties).length < 7, \"Cannot add more than 6 perpetual royalty amounts\");\n        \n        //iterate through the perpetual royalties and insert the account and amount in the royalty map\n        Object.entries(perpetualRoyalties).forEach(([account, amount], index) => {\n            royalty[account] = amount;\n        });\n    }\n\n    //specify the token struct that contains the owner ID \n    let token = new Token ({\n        //set the owner ID equal to the receiver ID passed into the function\n        ownerId: receiverId,\n        //we set the approved account IDs to the default value (an empty map)\n        approvedAccountIds: {},\n        //the next approval ID is set to 0\n        nextApprovalId: 0,\n        //the map of perpetual royalties for the token (The owner will get 100% - total perpetual royalties)\n        royalty,\n    });\n\n    //insert the token ID and token struct and make sure that the token doesn't exist\n    assert(!contract.tokensById.containsKey(tokenId), \"Token already exists\");\n    contract.tokensById.set(tokenId, token)\n\n    //insert the token ID and metadata\n    contract.tokenMetadataById.set(tokenId, metadata);\n\n    //call the internal method for adding the token to the owner\n    internalAddTokenToOwner(contract, token.owner_id, tokenId)\n\n    // Construct the mint log as per the events standard.\n    let nftMintLog = {\n        // Standard name (\"nep171\").\n        standard: NFT_STANDARD_NAME,\n        // Version of the standard (\"nft-1.0.0\").\n        version: NFT_METADATA_SPEC,\n        // The data related with the event stored in a vector.\n        event: \"nft_mint\",\n        data: [\n            {\n                // Owner of the token.\n                owner_id: token.owner_id,\n                // Vector of token IDs that were minted.\n                token_ids: [tokenId],\n            }\n        ]\n    }\n    \n    // Log the json.\n    near.log(`EVENT_JSON:${JSON.stringify(nftMintLog)}`);\n\n    //calculate the required storage which was the used - initial TODO\n    let requiredStorageInBytes = near.storageUsage().valueOf() - initialStorageUsage.valueOf();\n\n    //refund any excess storage if the user attached too much. Panic if they didn't attach enough to cover the required.\n    refundDeposit(requiredStorageInBytes);\n}","// @ts-nocheck\nimport { assert, bytes, near } from \"near-sdk-js\";\nimport { Contract, NFT_METADATA_SPEC, NFT_STANDARD_NAME } from \".\";\nimport { assertOneYocto, internalAddTokenToOwner, internalRemoveTokenFromOwner, internalTransfer, refundDeposit, refundApprovedAccountIds } from \"./internal\";\nimport { JsonToken, Token, TokenMetadata } from \"./metadata\";\n\nconst GAS_FOR_RESOLVE_TRANSFER = 40_000_000_000_000;\nconst GAS_FOR_NFT_ON_TRANSFER = 35_000_000_000_000;\n\n//get the information for a specific token ID\nexport function internalNftToken({\n    contract,\n    tokenId\n}:{ \n    contract: Contract, \n    tokenId: string \n}) {\n    let token = contract.tokensById.get(tokenId) as Token;\n    //if there wasn't a token ID in the tokens_by_id collection, we return None\n    if (token == null) {\n        return null;\n    }\n\n    //if there is some token ID in the tokens_by_id collection\n    //we'll get the metadata for that token\n    let metadata = contract.tokenMetadataById.get(tokenId) as TokenMetadata;\n    \n    //we return the JsonToken\n    let jsonToken = new JsonToken({\n        tokenId: tokenId,\n        ownerId: token.owner_id,\n        metadata,\n        approvedAccountIds: token.approved_account_ids,\n        royalty: token.royalty\n    });\n    return jsonToken;\n}\n\n//implementation of the nft_transfer method. This transfers the NFT from the current owner to the receiver. \nexport function internalNftTransfer({\n    contract,\n    receiverId,\n    tokenId,\n    approvalId,\n    memo,\n}:{\n    contract: Contract, \n    receiverId: string, \n    tokenId: string, \n    approvalId: number\n    memo: string\n}) {\n    //assert that the user attached exactly 1 yoctoNEAR. This is for security and so that the user will be redirected to the NEAR wallet. \n    assertOneYocto();\n    //get the sender to transfer the token from the sender to the receiver\n    let senderId = near.predecessorAccountId();\n\n    //call the internal transfer method and get back the previous token so we can refund the approved account IDs\n    let previousToken = internalTransfer(\n        contract,\n        senderId,\n        receiverId,\n        tokenId,\n        approvalId,\n        memo,\n    );\n\n    //we refund the owner for releasing the storage used up by the approved account IDs\n    refundApprovedAccountIds(\n        previousToken.owner_id,\n        previousToken.approved_account_ids\n    );\n}\n\n//implementation of the transfer call method. This will transfer the NFT and call a method on the receiver_id contract\nexport function internalNftTransferCall({\n    contract,\n    receiverId,\n    tokenId,\n    approvalId,\n    memo,\n    msg\n}:{\n    contract: Contract,\n    receiverId: string, \n    tokenId: string, \n    approvalId: number,\n    memo: string,\n    msg: string  \n}) {\n    //assert that the user attached exactly 1 yocto for security reasons. \n    assertOneYocto();\n    //get the sender to transfer the token from the sender to the receiver\n    let senderId = near.predecessorAccountId();\n\n    //call the internal transfer method and get back the previous token so we can refund the approved account IDs\n    let previousToken = internalTransfer(\n        contract,\n        senderId,\n        receiverId,\n        tokenId,\n        approvalId,\n        memo,\n    );\n\n    // Initiating receiver's call and the callback\n    const promise = near.promiseBatchCreate(receiverId);\n    near.promiseBatchActionFunctionCall(\n        promise, \n        \"nft_on_transfer\", \n        bytes(JSON.stringify({ \n            sender_id: senderId,\n            previous_owner_id: previousToken.owner_id,\n            token_id: tokenId,\n            msg\n        })), \n        0, // no deposit \n        GAS_FOR_NFT_ON_TRANSFER\n    );\n\n    // We then resolve the promise and call nft_resolve_transfer on our own contract\n    near.promiseThen(\n        promise, \n        near.currentAccountId(), \n        \"nft_resolve_transfer\", \n        bytes(JSON.stringify({\n            owner_id: previousToken.owner_id,\n            receiver_id: receiverId,\n            token_id: tokenId,\n            approved_account_ids: previousToken.approved_account_ids\n        })), \n        0, // no deposit \n        GAS_FOR_RESOLVE_TRANSFER\n    );\n    return near.promiseReturn(promise);\n}\n\n//resolves the cross contract call when calling nft_on_transfer in the nft_transfer_call method\n//returns true if the token was successfully transferred to the receiver_id\nexport function internalResolveTransfer({\n    contract,\n    authorizedId,\n    ownerId,\n    receiverId,\n    tokenId,\n    approvedAccountIds,\n    memo\n}:{\n    contract: Contract,\n    authorizedId: string,\n    ownerId: string,\n    receiverId: string,\n    tokenId: string,\n    approvedAccountIds: { [key: string]: number },\n    memo: string    \n}) {\n    assert(near.currentAccountId() === near.predecessorAccountId(), \"Only the contract itself can call this method\");\n    // Whether receiver wants to return token back to the sender, based on `nft_on_transfer`\n    // call result.\n    let result = near.promiseResult(0);\n    if (typeof result === 'string') {\n        //As per the standard, the nft_on_transfer should return whether we should return the token to it's owner or not\n        //if we need don't need to return the token, we simply return true meaning everything went fine\n        if (result === 'false') {\n            /* \n                since we've already transferred the token and nft_on_transfer returned false, we don't have to \n                revert the original transfer and thus we can just return true since nothing went wrong.\n            */\n            //we refund the owner for releasing the storage used up by the approved account IDs\n            refundApprovedAccountIds(ownerId, approvedAccountIds);\n            return true;\n        }\n    }\n\n    //get the token object if there is some token object\n    let token = contract.tokensById.get(tokenId) as Token;\n    if (token != null) {\n        if (token.owner_id != receiverId) {\n            //we refund the owner for releasing the storage used up by the approved account IDs\n            refundApprovedAccountIds(ownerId, approvedAccountIds);\n            // The token is not owner by the receiver anymore. Can't return it.\n            return true;\n        }\n    //if there isn't a token object, it was burned and so we return true\n    } else {\n        //we refund the owner for releasing the storage used up by the approved account IDs\n        refundApprovedAccountIds(ownerId, approvedAccountIds);\n        return true;\n    }\n\n    //we remove the token from the receiver\n    internalRemoveTokenFromOwner(contract, receiverId, tokenId);\n    //we add the token to the original owner\n    internalAddTokenToOwner(contract, ownerId, tokenId);\n\n    //we change the token struct's owner to be the original owner \n    token.owner_id = ownerId\n\n    //we refund the receiver any approved account IDs that they may have set on the token\n    refundApprovedAccountIds(receiverId, token.approved_account_ids);\n    //reset the approved account IDs to what they were before the transfer\n    token.approved_account_ids = approvedAccountIds;\n\n    //we inset the token b  ack into the tokens_by_id collection\n    contract.tokensById.set(tokenId, token);\n\n    /*\n        We need to log that the NFT was reverted back to the original owner.\n        The old_owner_id will be the receiver and the new_owner_id will be the\n        original owner of the token since we're reverting the transfer.\n    */\n\n    // Construct the transfer log as per the events standard.\n    let nftTransferLog = {\n        // Standard name (\"nep171\").\n        standard: NFT_STANDARD_NAME,\n        // Version of the standard (\"nft-1.0.0\").\n        version: NFT_METADATA_SPEC,\n        // The data related with the event stored in a vector.\n        event: \"nft_transfer\",\n        data: [\n            {\n                // The optional authorized account ID to transfer the token on behalf of the old owner.\n                authorized_id: authorizedId,\n                // The old owner's account ID.\n                old_owner_id: receiverId,\n                // The account ID of the new owner of the token.\n                new_owner_id: ownerId,\n                // A vector containing the token IDs as strings.\n                token_ids: [tokenId],\n                // An optional memo to include.\n                memo,\n            }\n        ]\n    }\n\n    // Log the serialized json.\n    near.log(JSON.stringify(nftTransferLog));\n\n    //return false\n    return false\n}","// @ts-nocheck\nimport { near, UnorderedSet } from \"near-sdk-js\";\nimport { Contract, NFT_METADATA_SPEC, NFT_STANDARD_NAME } from \".\";\nimport { restoreOwners } from \"./internal\";\nimport { JsonToken } from \"./metadata\";\nimport { internalNftToken } from \"./nft_core\";\n\n//Query for the total supply of NFTs on the contract\nexport function internalTotalSupply({\n    contract\n}:{\n    contract: Contract\n}): number {\n    //return the length of the token metadata by ID\n    return contract.tokenMetadataById.len();\n}\n\n//Query for nft tokens on the contract regardless of the owner using pagination\nexport function internalNftTokens({\n    contract,\n    fromIndex,\n    limit\n}:{ \n    contract: Contract, \n    fromIndex?: string, \n    limit?: number\n}): JsonToken[] {\n    let tokens = [];\n\n    //where to start pagination - if we have a fromIndex, we'll use that - otherwise start from 0 index\n    let start = fromIndex ? parseInt(fromIndex) : 0;\n    //take the first \"limit\" elements in the array. If we didn't specify a limit, use 50\n    let max = limit ? limit : 50;\n\n    let keys = contract.tokenMetadataById.toArray();\n    // Paginate through the keys using the fromIndex and limit\n    for (let i = start; i < keys.length && i < start + max; i++) {\n        // get the token object from the keys\n        let jsonToken = internalNftToken({contract, tokenId: keys[i][0]});\n        tokens.push(jsonToken);\n    }\n    return tokens;\n}\n\n//get the total supply of NFTs for a given owner\nexport function internalSupplyForOwner({\n    contract,\n    accountId\n}:{\n    contract: Contract, \n    accountId: string\n}): number {\n    //get the set of tokens for the passed in owner\n    let tokens = restoreOwners(contract.tokensPerOwner.get(accountId));\n    //if there isn't a set of tokens for the passed in account ID, we'll return 0\n    if (tokens == null) {\n        return 0\n    }\n\n    //if there is some set of tokens, we'll return the length \n    return tokens.len();\n}\n\n//Query for all the tokens for an owner\nexport function internalTokensForOwner({\n    contract,\n    accountId,\n    fromIndex,\n    limit\n}:{\n    contract: Contract, \n    accountId: string, \n    fromIndex?: string, \n    limit?: number\n}): JsonToken[] {\n    //get the set of tokens for the passed in owner\n    let tokenSet = restoreOwners(contract.tokensPerOwner.get(accountId));\n\n    //if there isn't a set of tokens for the passed in account ID, we'll return 0\n    if (tokenSet == null) {\n        return [];\n    }\n    \n    //where to start pagination - if we have a fromIndex, we'll use that - otherwise start from 0 index\n    let start = fromIndex ? parseInt(fromIndex) : 0;\n    //take the first \"limit\" elements in the array. If we didn't specify a limit, use 50\n    let max = limit ? limit : 50;\n\n    let keys = tokenSet.toArray();\n    let tokens: JsonToken[] = []\n    for(let i = start; i < max; i++) {\n        if(i >= keys.length) {\n            break;\n        }\n        let token = internalNftToken({contract, tokenId: keys[i]});\n        tokens.push(token);\n    }\n    return tokens;\n}","// @ts-nocheck\nimport { assert, bytes, near } from \"near-sdk-js\";\nimport { Contract, NFT_METADATA_SPEC, NFT_STANDARD_NAME } from \".\";\nimport { assertAtLeastOneYocto, assertOneYocto, bytesForApprovedAccountId, internalAddTokenToOwner, refundDeposit, refundApprovedAccountIds, refundApprovedAccountIdsIter } from \"./internal\";\nimport { Token } from \"./metadata\";\n\nconst GAS_FOR_NFT_ON_APPROVE = 35_000_000_000_000;\n\n//approve an account ID to transfer a token on your behalf\nexport function internalNftApprove({\n    contract,\n    tokenId,\n    accountId,\n    msg\n}:{ \n    contract: Contract, \n    tokenId: string, \n    accountId: string, \n    msg: string \n}) {\n    /*\n        assert at least one yocto for security reasons - this will cause a redirect to the NEAR wallet.\n        The user needs to attach enough to pay for storage on the contract\n    */\n    assertAtLeastOneYocto();\n\n    //get the token object from the token ID\n    let token = contract.tokensById.get(tokenId) as Token;\n    if (token == null) {\n        near.panic(\"no token\");\n    }\n    //make sure that the person calling the function is the owner of the token\n    assert(near.predecessorAccountId() === token.owner_id, \"Predecessor must be the token owner\");\n\n    //get the next approval ID if we need a new approval\n    let approvalId = token.next_approval_id;\n\n    //check if the account has been approved already for this token\n    let isNewApproval = token.approved_account_ids.hasOwnProperty(accountId);\n    token.approved_account_ids[accountId] = approvalId;\n\n    //if it was a new approval, we need to calculate how much storage is being used to add the account.\n    let storageUsed = isNewApproval ? bytesForApprovedAccountId(accountId) : 0;\n\n    //increment the token's next approval ID by 1\n    token.next_approval_id += 1;\n    //insert the token back into the tokens_by_id collection\n    contract.tokensById.set(tokenId, token);\n\n    //refund any excess storage attached by the user. If the user didn't attach enough, panic. \n    refundDeposit(BigInt(storageUsed));\n    \n    //if some message was passed into the function, we initiate a cross contract call on the\n    //account we're giving access to. \n    if (msg != null) {\n        // Initiating receiver's call and the callback\n        const promise = near.promiseBatchCreate(accountId);\n        near.promiseBatchActionFunctionCall(\n            promise, \n            \"nft_on_approve\", \n            bytes(JSON.stringify({ \n                token_id: tokenId,\n                owner_id: token.owner_id,\n                approval_id: approvalId,\n                msg\n            })), \n            0, // no deposit \n            GAS_FOR_NFT_ON_APPROVE\n        );\n\n        near.promiseReturn(promise);\n    }\n}\n\n//check if the passed in account has access to approve the token ID\nexport function internalNftIsApproved({\n    contract,\n    tokenId,\n    approvedAccountId,\n    approvalId\n}:{ \n    contract: Contract, \n    tokenId: string,\n    approvedAccountId: string, \n    approvalId: number \n}) {\n    //get the token object from the token_id\n    let token = contract.tokensById.get(tokenId) as Token;\n    if (token == null) {\n        near.panic(\"no token\");\n    }\n\n    //get the approval number for the passed in account ID\n    let approval = token.approved_account_ids[approvedAccountId];\n\n    //if there was no approval ID found for the account ID, we simply return false\n    if (approval == null) {\n        return false\n    }\n\n    //if there was some approval ID found for the account ID\n    //if there was no approval_id passed into the function, we simply return true\n    if (approvalId == null) {\n        return true\n    }\n\n    //if a specific approval_id was passed into the function\n    //return if the approval ID passed in matches the actual approval ID for the account\n    return approvalId == approval;\n}\n\n//revoke a specific account from transferring the token on your behalf\nexport function internalNftRevoke({\n    contract,\n    tokenId,\n    accountId\n}:{ \n    contract: Contract, \n    tokenId: string, \n    accountId: string \n}) {\n    //assert that the user attached exactly 1 yoctoNEAR for security reasons\n    assertOneYocto();\n\n    //get the token object using the passed in token_id\n    let token = contract.tokensById.get(tokenId) as Token;\n    if (token == null) {\n        near.panic(\"no token\");\n    }\n\n    //get the caller of the function and assert that they are the owner of the token\n    let predecessorAccountId = near.predecessorAccountId();\n    assert(predecessorAccountId == token.owner_id, \"only token owner can revoke\");\n     \n    //if the account ID was in the token's approval, we remove it\n    if (token.approved_account_ids.hasOwnProperty(accountId)) {\n        delete token.approved_account_ids[accountId];\n        \n        //refund the funds released by removing the approved_account_id to the caller of the function\n        refundApprovedAccountIdsIter(predecessorAccountId, [accountId]);\n        \n        //insert the token back into the tokens_by_id collection with the account_id removed from the approval list\n        contract.tokensById.set(tokenId, token);\n    }\n}\n\n//revoke all accounts from transferring the token on your behalf\nexport function internalNftRevokeAll({\n    contract,\n    tokenId\n}:{ \n    contract: Contract, \n    tokenId: string \n}) {\n    //assert that the caller attached exactly 1 yoctoNEAR for security\n    assertOneYocto();\n\n    //get the token object from the passed in token ID\n    let token = contract.tokensById.get(tokenId) as Token;\n    if (token == null) {\n        near.panic(\"no token\");\n    }\n\n    //get the caller and make sure they are the owner of the tokens\n    let predecessorAccountId = near.predecessorAccountId();\n    assert(predecessorAccountId == token.owner_id, \"only token owner can revoke\");\n\n    //only revoke if the approved account IDs for the token is not empty\n    if (token.approved_account_ids && Object.keys(token.approved_account_ids).length === 0 && Object.getPrototypeOf(token.approved_account_ids) === Object.prototype) {\n        //refund the approved account IDs to the caller of the function\n        refundApprovedAccountIds(predecessorAccountId, token.approved_account_ids);\n        //clear the approved account IDs\n        token.approved_account_ids = {};\n        //insert the token back into the tokens_by_id collection with the approved account IDs cleared\n        contract.tokensById.set(tokenId, token);\n    }\n}","// @ts-nocheck\nimport { assert, near } from \"near-sdk-js\";\nimport { Contract, NFT_METADATA_SPEC, NFT_STANDARD_NAME } from \".\";\nimport { assertAtLeastOneYocto, assertOneYocto, bytesForApprovedAccountId, internalAddTokenToOwner, internalTransfer, refundDeposit, refundApprovedAccountIds, refundApprovedAccountIdsIter, royaltyToPayout } from \"./internal\";\nimport { Token } from \"./metadata\";\n\n//calculates the payout for a token given the passed in balance. This is a view method\nexport function internalNftPayout({\n    contract,\n    tokenId,\n    balance,\n    maxLenPayout\n}:{\n    contract: Contract, \n    tokenId: string,\n    balance: bigint, \n    maxLenPayout: number,\n}): { payout: {[key: string]: string }} {\n    //get the token object\n    let token = contract.tokensById.get(tokenId) as Token;\n    if (token == null) {\n        near.panic(\"no token\");\n    }\n\n    //get the owner of the token\n    let ownerId = token.owner_id;\n    //keep track of the total perpetual royalties\n    let totalPerpetual = 0;\n    //keep track of the payout object to send back\n    let payoutObj: { [key: string]: string } = {};\n    //get the royalty object from token\n    let royalty = token.royalty;\n\n    //make sure we're not paying out to too many people (GAS limits this)\n    assert(Object.keys(royalty).length <= maxLenPayout, \"Market cannot payout to that many receivers\");\n    \n    //go through each key and value in the royalty object\n    Object.entries(royalty).forEach(([key, value], index) => {\n        //only insert into the payout if the key isn't the token owner (we add their payout at the end)\n        if (key != ownerId) {\n            payoutObj[key] = royaltyToPayout(value, balance);\n            totalPerpetual += value;\n        }\n    });\n\n    // payout to previous owner who gets 100% - total perpetual royalties\n    payoutObj[ownerId] = royaltyToPayout(10000 - totalPerpetual, balance);\n\n    //return the payout object\n    return {\n        payout: payoutObj\n    }\n}\n\n//transfers the token to the receiver ID and returns the payout object that should be payed given the passed in balance. \nexport function internalNftTransferPayout({\n    contract,\n    receiverId,\n    tokenId,\n    approvalId,\n    memo,\n    balance,\n    maxLenPayout\n}:{\n    contract: Contract, \n    receiverId: string, \n    tokenId: string,\n    approvalId: number,\n    memo: string,\n    balance: bigint,\n    maxLenPayout: number,\n}): { payout: {[key: string]: string }} {\n    //assert that the user attached 1 yocto NEAR for security reasons\n    assertOneYocto();\n    //get the sender ID\n    let senderId = near.predecessorAccountId();\n    //transfer the token to the passed in receiver and get the previous token object back\n    let previousToken: Token = internalTransfer(\n        contract,\n        senderId,\n        receiverId,\n        tokenId,\n        approvalId,\n        memo,\n    );\n\n    //refund the previous token owner for the storage used up by the previous approved account IDs\n    refundApprovedAccountIds(\n        previousToken.owner_id,\n        previousToken.approved_account_ids,\n    );\n\n    //get the owner of the token\n    let ownerId = previousToken.owner_id;\n    //keep track of the total perpetual royalties\n    let totalPerpetual = 0;\n    //keep track of the payout object to send back\n    let payoutObj: { [key: string]: string } = {};\n    //get the royalty object from token\n    let royalty = previousToken.royalty;\n\n    //make sure we're not paying out to too many people (GAS limits this)\n    assert(Object.keys(royalty).length <= maxLenPayout, \"Market cannot payout to that many receivers\");\n    \n    //go through each key and value in the royalty object\n    Object.entries(royalty).forEach(([key, value], index) => {\n        //only insert into the payout if the key isn't the token owner (we add their payout at the end)\n        if (key != ownerId) {\n            payoutObj[key] = royaltyToPayout(value, balance);\n            totalPerpetual += value;\n        }\n    });\n\n    // payout to previous owner who gets 100% - total perpetual royalties\n    payoutObj[ownerId] = royaltyToPayout(10000 - totalPerpetual, balance);\n\n    //return the payout object\n    return {\n        payout: payoutObj\n    }\n}","\nimport { NearContract, NearBindgen, near, call, view, LookupMap, UnorderedMap, Vector, UnorderedSet } from 'near-sdk-js'\nimport { NFTContractMetadata, Token, TokenMetadata, internalNftMetadata } from './metadata';\nimport { internalMint } from './mint';\nimport { internalNftTokens, internalSupplyForOwner, internalTokensForOwner, internalTotalSupply } from './enumeration';\nimport { internalNftToken, internalNftTransfer, internalNftTransferCall, internalResolveTransfer } from './nft_core';\nimport { internalNftApprove, internalNftIsApproved, internalNftRevoke, internalNftRevokeAll } from './approval';\nimport { internalNftPayout, internalNftTransferPayout } from './royalty';\n\n/// This spec can be treated like a version of the standard.\nexport const NFT_METADATA_SPEC = \"nft-1.0.0\";\n\n/// This is the name of the NFT standard we're using\nexport const NFT_STANDARD_NAME = \"nep171\";\n\n@NearBindgen\nexport class Contract extends NearContract {\n    owner_id: string;\n    tokensPerOwner: LookupMap;\n    tokensById: LookupMap;\n    tokenMetadataById: UnorderedMap;\n    metadata: NFTContractMetadata;\n\n    /*\n        initialization function (can only be called once).\n        this initializes the contract with metadata that was passed in and\n        the owner_id. \n    */\n    constructor({\n        owner_id, \n        metadata = {\n            spec: \"nft-1.0.0\",\n            name: \"Nosso Contrato de NFT\",\n            symbol: \"WEB3DEV\"\n        } \n    }) {\n        super()\n        this.owner_id = owner_id;\n        this.tokensPerOwner = new LookupMap(\"tokensPerOwner\");\n        this.tokensById = new LookupMap(\"tokensById\");\n        this.tokenMetadataById = new UnorderedMap(\"tokenMetadataById\");\n        this.metadata = metadata;\n    }\n\n    default() {\n        return new Contract({owner_id: ''})\n    }\n\n    /*\n        MINT\n    */\n    @call\n    nft_mint({ token_id, metadata, receiver_id, perpetual_royalties }) {\n        return internalMint({ contract: this, tokenId: token_id, metadata: metadata, receiverId: receiver_id, perpetualRoyalties: perpetual_royalties });\n    }\n\n    /*\n        CORE\n    */\n    @view\n    //get the information for a specific token ID\n    nft_token({ token_id }) {\n        return internalNftToken({ contract: this, tokenId: token_id });\n    }\n\n    @call\n    //implementation of the nft_transfer method. This transfers the NFT from the current owner to the receiver. \n    nft_transfer({ receiver_id, token_id, approval_id, memo }) {\n        return internalNftTransfer({ contract: this, receiverId: receiver_id, tokenId: token_id, approvalId: approval_id, memo: memo });\n    }\n\n    @call\n    //implementation of the transfer call method. This will transfer the NFT and call a method on the receiver_id contract\n    nft_transfer_call({ receiver_id, token_id, approval_id, memo, msg }) {\n        return internalNftTransferCall({ contract: this, receiverId: receiver_id, tokenId: token_id, approvalId: approval_id, memo: memo, msg: msg });\n    }\n\n    @call\n    //resolves the cross contract call when calling nft_on_transfer in the nft_transfer_call method\n    //returns true if the token was successfully transferred to the receiver_id\n    nft_resolve_transfer({ authorized_id, owner_id, receiver_id, token_id, approved_account_ids, memo }) {\n        return internalResolveTransfer({ contract: this, authorizedId: authorized_id, ownerId: owner_id, receiverId: receiver_id, tokenId: token_id, approvedAccountIds: approved_account_ids, memo: memo });\n    }\n\n    /*\n        APPROVALS\n    */\n    @view\n    //check if the passed in account has access to approve the token ID\n    nft_is_approved({ token_id, approved_account_id, approval_id }) {\n        return internalNftIsApproved({ contract: this, tokenId: token_id, approvedAccountId: approved_account_id, approvalId: approval_id });\n    }\n\n    @call\n    //approve an account ID to transfer a token on your behalf\n    nft_approve({ token_id, account_id, msg }) {\n        return internalNftApprove({ contract: this, tokenId: token_id, accountId: account_id, msg: msg });\n    }\n\n    /*\n        ROYALTY\n    */\n    @view\n    //calculates the payout for a token given the passed in balance. This is a view method\n    nft_payout({ token_id, balance, max_len_payout }) {\n        return internalNftPayout({ contract: this, tokenId: token_id, balance: balance, maxLenPayout: max_len_payout });\n    }\n\n    @call\n    //transfers the token to the receiver ID and returns the payout object that should be payed given the passed in balance. \n    nft_transfer_payout({ receiver_id, token_id, approval_id, memo, balance, max_len_payout }) {\n        return internalNftTransferPayout({ contract: this, receiverId: receiver_id, tokenId: token_id, approvalId: approval_id, memo: memo, balance: balance, maxLenPayout: max_len_payout });\n    }\n\n    @call\n    //approve an account ID to transfer a token on your behalf\n    nft_revoke({ token_id, account_id }) {\n        return internalNftRevoke({ contract: this, tokenId: token_id, accountId: account_id });\n    }\n\n    @call\n    //approve an account ID to transfer a token on your behalf\n    nft_revoke_all({ token_id }) {\n        return internalNftRevokeAll({ contract: this, tokenId: token_id });\n    }\n\n    /*\n        ENUMERATION\n    */\n    @view\n    //Query for the total supply of NFTs on the contract\n    nft_total_supply() {\n        return internalTotalSupply({ contract: this });\n    }\n\n    @view\n    //Query for nft tokens on the contract regardless of the owner using pagination\n    nft_tokens({ from_index, limit }) {\n        return internalNftTokens({ contract: this, fromIndex: from_index, limit: limit });\n    }\n\n    @view\n    //get the total supply of NFTs for a given owner\n    nft_tokens_for_owner({ account_id, from_index, limit }) {\n        return internalTokensForOwner({ contract: this, accountId: account_id, fromIndex: from_index, limit: limit });\n    }\n\n    @view\n    //Query for all the tokens for an owner\n    nft_supply_for_owner({ account_id }) {\n        return internalSupplyForOwner({ contract: this, accountId: account_id });\n    }\n\n    /*\n        METADATA\n    */\n    @view\n    //Query for all the tokens for an owner\n    nft_metadata() {\n        return internalNftMetadata({ contract: this });\n    }\n}"],"names":["call","target","key","descriptor","view","NearBindgen","_init","args","deserializeArgs","ret","init","serialize","_get","Object","create","prototype","U64_MAX","EVICTED_REGISTER","log","params","env","map","x","undefined","JSON","stringify","join","predecessorAccountId","predecessor_account_id","read_register","attachedDeposit","attached_deposit","panic","msg","storageRead","storage_read","storageHasKey","storage_has_key","storageGetEvicted","currentAccountId","current_account_id","input","storageUsage","storage_usage","promiseThen","promiseIndex","accountId","methodName","amount","gas","promise_then","promiseBatchCreate","promise_batch_create","promiseBatchActionFunctionCall","promise_batch_action_function_call","promiseBatchActionTransfer","promise_batch_action_transfer","PromiseResult","promiseResult","resultIdx","status","promise_result","Successful","Failed","NotReady","promiseReturn","promiseIdx","promise_return","storageWrite","value","exist","storage_write","storageRemove","storage_remove","storageByteCost","NearContract","deserialize","rawState","near","state","parse","c","default","assign","item","constructor","Error","serializeReturn","LookupMap","keyPrefix","containsKey","storageKey","get","raw","remove","set","storageValue","extend","objects","kv","data","u8ArrayToBytes","array","e","String","fromCharCode","bytesToU8Array","bytes","Uint8Array","length","i","charCodeAt","strOrU8Array","checkStringIsBytes","str","assert","b","ERR_INDEX_OUT_OF_BOUNDS","ERR_INCONSISTENT_STATE","indexToKey","prefix","index","Uint32Array","buffer","Vector","len","isEmpty","swapRemove","pop","last","push","element","lastIndex","lastKey","replace","elements","Symbol","iterator","VectorIterator","clear","toArray","v","vector","current","next","done","UnorderedMap","keyIndexPrefix","indexKey","indexValue","keys","values","keysLen","valuesLen","keysIsEmpty","valuesIsEmpty","serializeIndex","deserializeIndex","rawIndex","getIndexRaw","indexLookup","indexRaw","nextIndex","nextIndexRaw","lastLookupKey","UnorderedMapIterator","kvs","k","unorderedMap","UnorderedSet","elementIndexPrefix","elementsPrefix","contains","lastElement","lastLookupElement","Token","ownerId","approvedAccountIds","nextApprovalId","royalty","owner_id","approved_account_ids","next_approval_id","JsonToken","tokenId","metadata","token_id","internalNftMetadata","contract","restoreOwners","collection","royaltyToPayout","royaltyPercentage","amountToPay","BigInt","toString","refundApprovedAccountIdsIter","storageReleased","bytesForApprovedAccountId","reduce","partialSum","a","amountToTransfer","valueOf","promise","refundApprovedAccountIds","refundDeposit","storageUsed","requiredCost","refund","assertAtLeastOneYocto","assertOneYocto","internalAddTokenToOwner","tokenSet","tokensPerOwner","internalRemoveTokenFromOwner","internalTransfer","senderId","receiverId","approvalId","memo","token","tokensById","hasOwnProperty","actualApprovalId","newToken","authorizedId","nftTransferLog","standard","NFT_STANDARD_NAME","version","NFT_METADATA_SPEC","event","authorized_id","old_owner_id","new_owner_id","token_ids","internalMint","perpetualRoyalties","initialStorageUsage","entries","forEach","account","tokenMetadataById","nftMintLog","requiredStorageInBytes","GAS_FOR_RESOLVE_TRANSFER","GAS_FOR_NFT_ON_TRANSFER","internalNftToken","jsonToken","internalNftTransfer","previousToken","internalNftTransferCall","sender_id","previous_owner_id","receiver_id","internalResolveTransfer","result","internalTotalSupply","internalNftTokens","fromIndex","limit","tokens","start","parseInt","max","internalSupplyForOwner","internalTokensForOwner","GAS_FOR_NFT_ON_APPROVE","internalNftApprove","isNewApproval","approval_id","internalNftIsApproved","approvedAccountId","approval","internalNftRevoke","internalNftRevokeAll","getPrototypeOf","internalNftPayout","balance","maxLenPayout","totalPerpetual","payoutObj","payout","internalNftTransferPayout","Contract","spec","name","symbol","nft_mint","perpetual_royalties","nft_token","nft_transfer","nft_transfer_call","nft_resolve_transfer","nft_is_approved","approved_account_id","nft_approve","account_id","nft_payout","max_len_payout","nft_transfer_payout","nft_revoke","nft_revoke_all","nft_total_supply","nft_tokens","from_index","nft_tokens_for_owner","nft_supply_for_owner","nft_metadata"],"mappings":"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"}